# è®¾è®¡æ–‡æ¡£

## ç®€ä»‹

æœ¬æ–‡æ¡£æè¿°äº† SpecBridge é¡¹ç›®æ¡†æ¶çš„å®Œæ•´æŠ€æœ¯è®¾è®¡ã€‚SpecBridge æ˜¯ä¸€ä¸ªè½»é‡çº§ CLI å·¥å…·ï¼Œé‡‡ç”¨åŒé€‚é…å™¨æ¶æ„å°† AI ç”Ÿæˆçš„è§„æ ¼æ–‡æ¡£åŒæ­¥åˆ°é¡¹ç›®ç®¡ç†å¹³å°ã€‚æœ¬è®¾è®¡æ¶µç›–æ ¸å¿ƒæ•°æ®æ¨¡å‹ã€é€‚é…å™¨æ¥å£ã€åŒæ­¥å¼•æ“ã€é…ç½®ç³»ç»Ÿã€CLI æ¡†æ¶ä»¥åŠ Kiro å’Œ GitHub é€‚é…å™¨çš„å®Œæ•´å®ç°ã€‚

## ç³»ç»Ÿæ¶æ„

### æ¶æ„æ¦‚è§ˆ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      SpecBridge CLI                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚ æºé€‚é…å™¨      â”‚              â”‚ ç›®æ ‡é€‚é…å™¨    â”‚            â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤              â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤            â”‚
â”‚  â”‚ - Kiro       â”‚              â”‚ - GitHub     â”‚            â”‚
â”‚  â”‚ - OpenSpec   â”‚              â”‚ - Jira       â”‚            â”‚
â”‚  â”‚ - è‡ªå®šä¹‰     â”‚              â”‚ - CodeUp     â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚         â”‚                             â”‚                    â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â”‚
â”‚                    â”‚                                       â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                            â”‚
â”‚         â”‚   åŒæ­¥å¼•æ“           â”‚                            â”‚
â”‚         â”‚  (æ ¸å¿ƒé€»è¾‘)          â”‚                            â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                            â”‚
â”‚                    â”‚                                       â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                            â”‚
â”‚         â”‚   é…ç½®ç®¡ç†å™¨         â”‚                            â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                            â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ•°æ®æµ

```
1. ç”¨æˆ·æ‰§è¡Œ CLI å‘½ä»¤
   â†“
2. é…ç½®ç®¡ç†å™¨åŠ è½½ .specbridge.yaml
   â†“
3. æºé€‚é…å™¨è§£æè§„æ ¼æ–‡ä»¶ â†’ ç»Ÿä¸€æ•°æ®æ¨¡å‹ (SpecData)
   â†“
4. åŒæ­¥å¼•æ“åè°ƒåŒæ­¥è¿‡ç¨‹
   â†“
5. ç›®æ ‡é€‚é…å™¨å°†æ•°æ®åŒæ­¥åˆ°å¹³å°
   â†“
6. è¿”å›åŒæ­¥ç»“æœå¹¶è®°å½•å˜æ›´
```

## æ ¸å¿ƒç»„ä»¶è®¾è®¡

### 1. ç»Ÿä¸€æ•°æ®æ¨¡å‹ (éœ€æ±‚ 1)

**è®¾è®¡å†³ç­–**ï¼šä½¿ç”¨ç»Ÿä¸€çš„æ•°æ®æ¨¡å‹ä½œä¸ºæ‰€æœ‰é€‚é…å™¨ä¹‹é—´çš„ä¸­é—´è¡¨ç¤ºï¼Œç¡®ä¿æºå’Œç›®æ ‡é€‚é…å™¨è§£è€¦ã€‚


#### æ•°æ®æ¨¡å‹ç»“æ„

```typescript
// src/core/models.ts

/**
 * è§„æ ¼å…ƒæ•°æ®
 */
export interface SpecMeta {
  name: string;           // è§„æ ¼åç§°ï¼ˆå¦‚ "user-authentication"ï¼‰
  version: string;        // ç‰ˆæœ¬å·ï¼ˆå¦‚ "1.0.0"ï¼‰
  createdAt: string;      // ISO 8601 æ—¶é—´æˆ³
  updatedAt: string;      // ISO 8601 æ—¶é—´æˆ³
}

/**
 * ä»»åŠ¡çŠ¶æ€æšä¸¾
 */
export enum TaskStatus {
  TODO = 'todo',
  IN_PROGRESS = 'in_progress',
  DONE = 'done',
  BLOCKED = 'blocked'
}

/**
 * éœ€æ±‚å®šä¹‰
 */
export interface Requirement {
  id: string;             // å”¯ä¸€æ ‡è¯†ç¬¦
  title: string;          // éœ€æ±‚æ ‡é¢˜
  description: string;    // éœ€æ±‚æè¿°
  priority?: string;      // ä¼˜å…ˆçº§ï¼ˆhigh/medium/lowï¼‰
  labels?: string[];      // æ ‡ç­¾æ•°ç»„
  syncId?: string;        // åŒæ­¥åˆ°ç›®æ ‡å¹³å°çš„ IDï¼ˆå¦‚ GitHub Issue #123ï¼‰
}

/**
 * ä»»åŠ¡å®šä¹‰
 */
export interface Task {
  id: string;             // å”¯ä¸€æ ‡è¯†ç¬¦
  title: string;          // ä»»åŠ¡æ ‡é¢˜
  description?: string;   // ä»»åŠ¡æè¿°
  status: TaskStatus;     // ä»»åŠ¡çŠ¶æ€
  assignee?: string;      // è´Ÿè´£äºº
  parentId?: string;      // çˆ¶ä»»åŠ¡ IDï¼ˆç”¨äºå­ä»»åŠ¡ï¼‰
  labels?: string[];      // æ ‡ç­¾æ•°ç»„
  syncId?: string;        // åŒæ­¥åˆ°ç›®æ ‡å¹³å°çš„ ID
}

/**
 * è®¾è®¡æ–‡æ¡£
 */
export interface Design {
  content: string;        // è®¾è®¡æ–‡æ¡£çš„å®Œæ•´å†…å®¹ï¼ˆMarkdownï¼‰
  sections?: {            // å¯é€‰çš„ç»“æ„åŒ–ç« èŠ‚
    [key: string]: string;
  };
}

/**
 * åŒæ­¥å˜æ›´è®°å½•
 */
export interface SyncChange {
  timestamp: string;      // ISO 8601 æ—¶é—´æˆ³
  action: 'created' | 'updated' | 'closed';  // æ“ä½œç±»å‹
  itemType: 'requirement' | 'task' | 'design';  // é¡¹ç›®ç±»å‹
  itemId: string;         // é¡¹ç›® ID
  changes?: {             // å…·ä½“å˜æ›´å†…å®¹
    field: string;        // å˜æ›´å­—æ®µ
    oldValue?: any;       // æ—§å€¼
    newValue?: any;       // æ–°å€¼
  }[];
}

/**
 * åŒæ­¥ç»“æœ
 */
export interface SyncResult {
  success: boolean;       // æ˜¯å¦æˆåŠŸ
  created: number;        // åˆ›å»ºæ•°é‡
  updated: number;        // æ›´æ–°æ•°é‡
  failed: number;         // å¤±è´¥æ•°é‡
  changes: SyncChange[];  // å˜æ›´è¯¦æƒ…
  errors?: string[];      // é”™è¯¯æ¶ˆæ¯
}

/**
 * è§„æ ¼æ•°æ®ï¼ˆé¡¶å±‚å®¹å™¨ï¼‰
 */
export interface SpecData {
  meta: SpecMeta;
  requirements: Requirement[];
  design?: Design;
  tasks: Task[];
}
```

**è®¾è®¡ç†ç”±**ï¼š
- ä½¿ç”¨ TypeScript æ¥å£ç¡®ä¿ç±»å‹å®‰å…¨
- æ‰€æœ‰ ID ä½¿ç”¨å­—ç¬¦ä¸²ç±»å‹ä»¥æ”¯æŒä¸åŒå¹³å°çš„ ID æ ¼å¼
- syncId å­—æ®µç”¨äºè·Ÿè¸ªåŒæ­¥çŠ¶æ€ï¼Œé¿å…é‡å¤åˆ›å»º
- SyncChange æä¾›è¯¦ç»†çš„å˜æ›´è¿½è¸ªï¼Œä¾¿äºå®¡è®¡å’Œè°ƒè¯•

### 2. æºé€‚é…å™¨æ¥å£ (éœ€æ±‚ 2)

**è®¾è®¡å†³ç­–**ï¼šå®šä¹‰ç»Ÿä¸€çš„æºé€‚é…å™¨æ¥å£ï¼Œæ”¯æŒå¤šç§è§„æ ¼æ–‡æ¡£æ ¼å¼ã€‚

#### æ¥å£å®šä¹‰

```typescript
// src/adapters/source/base.ts

/**
 * æºé€‚é…å™¨æ¥å£
 * è´Ÿè´£ä»å„ç§æ¥æºè¯»å–å’Œè§£æè§„æ ¼æ–‡æ¡£
 */
export interface SourceAdapter {
  /** é€‚é…å™¨åç§° */
  name: string;
  
  /**
   * æ£€æµ‹æ˜¯å¦å¯ä»¥å¤„ç†æŒ‡å®šè·¯å¾„
   * @param path è§„æ ¼æ–‡æ¡£è·¯å¾„
   * @returns æ˜¯å¦æ”¯æŒè¯¥è·¯å¾„
   */
  detect(path: string): boolean;
  
  /**
   * è§£æè§„æ ¼æ–‡æ¡£
   * @param path è§„æ ¼æ–‡æ¡£è·¯å¾„
   * @returns è§£æåçš„è§„æ ¼æ•°æ®
   */
  parse(path: string): Promise<SpecData>;
  
  /**
   * ç›‘å¬æ–‡ä»¶å˜åŒ–ï¼ˆå¯é€‰ï¼‰
   * @param path è§„æ ¼æ–‡æ¡£è·¯å¾„
   * @param callback å˜åŒ–å›è°ƒå‡½æ•°
   */
  watch?(path: string, callback: (data: SpecData) => void): void;
}

/**
 * åŸºç¡€æºé€‚é…å™¨æŠ½è±¡ç±»
 * æä¾›é€šç”¨åŠŸèƒ½å®ç°
 */
export abstract class BaseSourceAdapter implements SourceAdapter {
  abstract name: string;
  abstract detect(path: string): boolean;
  abstract parse(path: string): Promise<SpecData>;
  
  /**
   * éªŒè¯è§£æç»“æœ
   */
  protected validateSpecData(data: SpecData): void {
    if (!data.meta || !data.meta.name) {
      throw new Error('Invalid SpecData: missing meta.name');
    }
    if (!Array.isArray(data.tasks)) {
      throw new Error('Invalid SpecData: tasks must be an array');
    }
  }
}
```

**è®¾è®¡ç†ç”±**ï¼š
- detect æ–¹æ³•å…è®¸è‡ªåŠ¨æ£€æµ‹é€‚é…å™¨ç±»å‹
- parse æ–¹æ³•è¿”å› Promise æ”¯æŒå¼‚æ­¥æ–‡ä»¶è¯»å–
- watch æ–¹æ³•ä¸ºå¯é€‰ï¼Œæ”¯æŒå®æ—¶åŒæ­¥åœºæ™¯
- BaseSourceAdapter æä¾›é€šç”¨éªŒè¯é€»è¾‘ï¼Œå‡å°‘é‡å¤ä»£ç 

### 3. ç›®æ ‡é€‚é…å™¨æ¥å£ (éœ€æ±‚ 3)

**è®¾è®¡å†³ç­–**ï¼šå®šä¹‰ç»Ÿä¸€çš„ç›®æ ‡é€‚é…å™¨æ¥å£ï¼Œæ”¯æŒå¤šç§é¡¹ç›®ç®¡ç†å¹³å°ã€‚


#### æ¥å£å®šä¹‰

```typescript
// src/adapters/target/base.ts

/**
 * ç›®æ ‡é€‚é…å™¨æ¥å£
 * è´Ÿè´£å°†æ•°æ®åŒæ­¥åˆ°é¡¹ç›®ç®¡ç†å¹³å°
 */
export interface TargetAdapter {
  /** é€‚é…å™¨åç§° */
  name: string;
  
  /**
   * åˆå§‹åŒ–é€‚é…å™¨
   * @param config é€‚é…å™¨é…ç½®
   */
  init(config: any): Promise<void>;
  
  /**
   * åŒæ­¥éœ€æ±‚
   * @param requirements éœ€æ±‚æ•°ç»„
   * @returns åŒæ­¥ç»“æœ
   */
  syncRequirements(requirements: Requirement[]): Promise<SyncResult>;
  
  /**
   * åŒæ­¥ä»»åŠ¡
   * @param tasks ä»»åŠ¡æ•°ç»„
   * @returns åŒæ­¥ç»“æœ
   */
  syncTasks(tasks: Task[]): Promise<SyncResult>;
  
  /**
   * åŒæ­¥è®¾è®¡æ–‡æ¡£ï¼ˆå¯é€‰ï¼‰
   * @param design è®¾è®¡æ–‡æ¡£
   * @returns åŒæ­¥ç»“æœ
   */
  syncDesign?(design: Design): Promise<SyncResult>;
  
  /**
   * è·å–ä»»åŠ¡çŠ¶æ€
   * @param taskId ä»»åŠ¡ ID
   * @returns ä»»åŠ¡çŠ¶æ€
   */
  getTaskStatus(taskId: string): Promise<TaskStatus>;
}

/**
 * åŸºç¡€ç›®æ ‡é€‚é…å™¨æŠ½è±¡ç±»
 */
export abstract class BaseTargetAdapter implements TargetAdapter {
  abstract name: string;
  protected config: any;
  
  abstract init(config: any): Promise<void>;
  abstract syncRequirements(requirements: Requirement[]): Promise<SyncResult>;
  abstract syncTasks(tasks: Task[]): Promise<SyncResult>;
  abstract getTaskStatus(taskId: string): Promise<TaskStatus>;
  
  /**
   * åˆ›å»ºåŒæ­¥ç»“æœå¯¹è±¡
   */
  protected createSyncResult(): SyncResult {
    return {
      success: true,
      created: 0,
      updated: 0,
      failed: 0,
      changes: [],
      errors: []
    };
  }
}
```

**è®¾è®¡ç†ç”±**ï¼š
- init æ–¹æ³•åˆ†ç¦»åˆå§‹åŒ–é€»è¾‘ï¼Œæ”¯æŒå»¶è¿Ÿé…ç½®
- åˆ†ç¦» syncRequirementsã€syncTasksã€syncDesign æ–¹æ³•ï¼Œæä¾›ç»†ç²’åº¦æ§åˆ¶
- getTaskStatus æ”¯æŒçŠ¶æ€æŸ¥è¯¢ï¼Œä¾¿äºåŒå‘åŒæ­¥
- BaseTargetAdapter æä¾›é€šç”¨å·¥å…·æ–¹æ³•

### 4. é…ç½®ç®¡ç†ç³»ç»Ÿ (éœ€æ±‚ 4)

**è®¾è®¡å†³ç­–**ï¼šä½¿ç”¨ YAML é…ç½®æ–‡ä»¶ï¼Œæ”¯æŒç¯å¢ƒå˜é‡æ›¿æ¢å’Œé…ç½®éªŒè¯ã€‚

#### é…ç½®æ¥å£

```typescript
// src/core/config.ts

/**
 * æºé…ç½®
 */
export interface SourceConfig {
  type: string;           // é€‚é…å™¨ç±»å‹ï¼ˆkiro/openspec/customï¼‰
  path?: string;          // è§„æ ¼æ–‡æ¡£è·¯å¾„ï¼ˆå¯é€‰ï¼Œè‡ªåŠ¨æ£€æµ‹ï¼‰
  plugin?: string;        // è‡ªå®šä¹‰æ’ä»¶è·¯å¾„
}

/**
 * ç›®æ ‡é…ç½®
 */
export interface TargetConfig {
  name: string;           // ç›®æ ‡åç§°
  type: string;           // é€‚é…å™¨ç±»å‹ï¼ˆgithub/jira/customï¼‰
  enabled: boolean;       // æ˜¯å¦å¯ç”¨
  config: any;            // å¹³å°ç‰¹å®šé…ç½®
  mapping?: {             // æ˜ å°„é…ç½®
    requirements?: string;  // éœ€æ±‚æ˜ å°„ç±»å‹
    tasks?: string;         // ä»»åŠ¡æ˜ å°„ç±»å‹
    design?: string;        // è®¾è®¡æ˜ å°„ç±»å‹
  };
  plugin?: string;        // è‡ªå®šä¹‰æ’ä»¶è·¯å¾„
}

/**
 * é€šçŸ¥é…ç½®
 */
export interface NotificationConfig {
  type: string;           // é€šçŸ¥ç±»å‹ï¼ˆslack/emailï¼‰
  config: any;            // é€šçŸ¥é…ç½®
  events?: string[];      // ç›‘å¬çš„äº‹ä»¶
}

/**
 * ä¸»é…ç½®
 */
export interface Config {
  version: string;        // é…ç½®ç‰ˆæœ¬
  source: SourceConfig;
  targets: TargetConfig[];
  notifications?: NotificationConfig[];
}

/**
 * åŠ è½½é…ç½®æ–‡ä»¶
 * @param configPath é…ç½®æ–‡ä»¶è·¯å¾„ï¼ˆé»˜è®¤ .specbridge.yamlï¼‰
 * @returns é…ç½®å¯¹è±¡
 */
export async function loadConfig(configPath?: string): Promise<Config>;

/**
 * éªŒè¯é…ç½®
 * @param config é…ç½®å¯¹è±¡
 * @throws ConfigParseError å¦‚æœé…ç½®æ— æ•ˆ
 */
export function validateConfig(config: Config): void;

/**
 * æ›¿æ¢ç¯å¢ƒå˜é‡
 * @param value åŒ…å« ${VAR} çš„å­—ç¬¦ä¸²
 * @returns æ›¿æ¢åçš„å­—ç¬¦ä¸²
 */
export function replaceEnvVars(value: string): string;
```

#### é…ç½®æ–‡ä»¶ç¤ºä¾‹

```yaml
# .specbridge.yaml
version: "1.0"

source:
  type: kiro
  path: .kiro/specs

targets:
  - name: github-issues
    type: github
    enabled: true
    config:
      owner: your-org
      repo: your-repo
      token: ${GITHUB_TOKEN}
      authMethod: token  # token | gh-cli
      addComments: true  # æ˜¯å¦æ·»åŠ åŒæ­¥è¯„è®º
    mapping:
      requirements: issue
      tasks: issue

notifications:
  - type: slack
    config:
      webhook: ${SLACK_WEBHOOK}
    events:
      - task_completed
      - sync_failed
```

**è®¾è®¡ç†ç”±**ï¼š
- YAML æ ¼å¼æ˜“è¯»æ˜“å†™
- ç¯å¢ƒå˜é‡æ›¿æ¢é¿å…æ•æ„Ÿä¿¡æ¯æ³„éœ²
- æ”¯æŒå¤šç›®æ ‡é…ç½®ï¼Œå®ç°ä¸€å¯¹å¤šåŒæ­¥
- mapping é…ç½®æä¾›çµæ´»çš„æ•°æ®æ˜ å°„ç­–ç•¥

### 5. åŒæ­¥å¼•æ“ (éœ€æ±‚ 5)

**è®¾è®¡å†³ç­–**ï¼šåŒæ­¥å¼•æ“ä½œä¸ºæ ¸å¿ƒåè°ƒå™¨ï¼Œç®¡ç†æºå’Œç›®æ ‡é€‚é…å™¨ä¹‹é—´çš„æ•°æ®æµã€‚


#### åŒæ­¥å¼•æ“è®¾è®¡

```typescript
// src/core/sync-engine.ts

/**
 * åŒæ­¥çŠ¶æ€
 */
export interface SyncStatus {
  lastSync?: string;      // ä¸Šæ¬¡åŒæ­¥æ—¶é—´
  status: 'idle' | 'syncing' | 'error';
  results?: SyncResult[];
}

/**
 * åŒæ­¥é€‰é¡¹
 */
export interface SyncOptions {
  scope?: 'all' | 'requirements' | 'tasks' | 'single';
  itemId?: string;        // å½“ scope ä¸º single æ—¶æŒ‡å®š
  dryRun?: boolean;       // ä»…æ¨¡æ‹Ÿï¼Œä¸å®é™…åŒæ­¥
}

/**
 * åŒæ­¥å¼•æ“
 */
export class SyncEngine {
  private status: SyncStatus;
  private history: SyncResult[];
  
  constructor() {
    this.status = { status: 'idle' };
    this.history = [];
  }
  
  /**
   * æ‰§è¡ŒåŒæ­¥
   * @param source æºé€‚é…å™¨
   * @param targets ç›®æ ‡é€‚é…å™¨æ•°ç»„
   * @param options åŒæ­¥é€‰é¡¹
   */
  async sync(
    source: SourceAdapter,
    targets: TargetAdapter[],
    options?: SyncOptions
  ): Promise<SyncResult[]>;
  
  /**
   * è·å–å½“å‰åŒæ­¥çŠ¶æ€
   */
  getStatus(): SyncStatus;
  
  /**
   * è·å–åŒæ­¥å†å²
   */
  getHistory(): SyncResult[];
}
```

#### åŒæ­¥æµç¨‹

```
1. æ›´æ–°çŠ¶æ€ä¸º 'syncing'
2. è°ƒç”¨æºé€‚é…å™¨è§£æè§„æ ¼
3. æ ¹æ® scope è¿‡æ»¤æ•°æ®
4. éå†æ‰€æœ‰å¯ç”¨çš„ç›®æ ‡é€‚é…å™¨ï¼š
   a. è°ƒç”¨ init åˆå§‹åŒ–
   b. æ ¹æ® mapping é…ç½®è°ƒç”¨ç›¸åº”çš„ sync æ–¹æ³•
   c. æ”¶é›†åŒæ­¥ç»“æœ
   d. å¦‚æœå¤±è´¥ï¼Œè®°å½•é”™è¯¯ä½†ç»§ç»­å¤„ç†å…¶ä»–ç›®æ ‡
5. æ›´æ–°åŒæ­¥å†å²
6. æ›´æ–°çŠ¶æ€ä¸º 'idle' æˆ– 'error'
7. è¿”å›æ‰€æœ‰åŒæ­¥ç»“æœ
```

**è®¾è®¡ç†ç”±**ï¼š
- é›†ä¸­ç®¡ç†åŒæ­¥é€»è¾‘ï¼Œç®€åŒ– CLI å‘½ä»¤å®ç°
- æ”¯æŒå¤šç›®æ ‡å¹¶è¡ŒåŒæ­¥ï¼Œæé«˜æ•ˆç‡
- é”™è¯¯éš”ç¦»ï¼šå•ä¸ªç›®æ ‡å¤±è´¥ä¸å½±å“å…¶ä»–ç›®æ ‡
- åŒæ­¥å†å²è®°å½•ä¾¿äºè°ƒè¯•å’Œå®¡è®¡

### 6. CLI å‘½ä»¤ç»“æ„ (éœ€æ±‚ 6)

**è®¾è®¡å†³ç­–**ï¼šä½¿ç”¨ Commander.js æ„å»ºæ¸…æ™°çš„å‘½ä»¤è¡Œç•Œé¢ã€‚

#### CLI æ¶æ„

```typescript
// src/index.ts

#!/usr/bin/env node
import { Command } from 'commander';
import { initCommand } from './cli/commands/init';
import { syncCommand } from './cli/commands/sync';
import { statusCommand } from './cli/commands/status';

const program = new Command();

program
  .name('specbridge')
  .description('AI-driven spec to project management platform sync tool')
  .version('0.1.0');

// å…¨å±€é€‰é¡¹
program.option('-v, --verbose', 'Enable verbose logging');

// æ³¨å†Œå‘½ä»¤
program.addCommand(initCommand);
program.addCommand(syncCommand);
program.addCommand(statusCommand);

// é”™è¯¯å¤„ç†
program.exitOverride();

try {
  program.parse(process.argv);
} catch (error) {
  handleError(error);
  process.exit(1);
}
```

#### å‘½ä»¤å®ç°

```typescript
// src/cli/commands/init.ts
export const initCommand = new Command('init')
  .description('Initialize SpecBridge configuration')
  .option('-f, --force', 'Overwrite existing configuration')
  .action(async (options) => {
    // å®ç°åˆå§‹åŒ–é€»è¾‘
  });

// src/cli/commands/sync.ts
export const syncCommand = new Command('sync')
  .description('Sync specs to project management platforms')
  .option('--scope <type>', 'Sync scope: all|requirements|tasks|single', 'all')
  .option('--id <id>', 'Item ID when scope is single')
  .option('--dry-run', 'Simulate sync without making changes')
  .action(async (options) => {
    // å®ç°åŒæ­¥é€»è¾‘
  });

// src/cli/commands/status.ts
export const statusCommand = new Command('status')
  .description('Show current sync status')
  .action(async () => {
    // å®ç°çŠ¶æ€æŸ¥è¯¢é€»è¾‘
  });
```

**è®¾è®¡ç†ç”±**ï¼š
- Commander.js æä¾›å¼ºå¤§çš„å‘½ä»¤è§£æèƒ½åŠ›
- åˆ†ç¦»å‘½ä»¤å®ç°ï¼Œä¿æŒä»£ç ç»„ç»‡æ¸…æ™°
- å…¨å±€é€‰é¡¹ï¼ˆå¦‚ --verboseï¼‰é€‚ç”¨äºæ‰€æœ‰å‘½ä»¤
- ç»Ÿä¸€çš„é”™è¯¯å¤„ç†æœºåˆ¶

### 7. æ—¥å¿—å·¥å…· (éœ€æ±‚ 7)

**è®¾è®¡å†³ç­–**ï¼šä½¿ç”¨ chalk å’Œ ora æä¾›ç¾è§‚çš„æ§åˆ¶å°è¾“å‡ºã€‚

#### æ—¥å¿—å·¥å…·è®¾è®¡

```typescript
// src/utils/logger.ts
import chalk from 'chalk';
import ora, { Ora } from 'ora';

/**
 * æ—¥å¿—çº§åˆ«
 */
export enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3
}

/**
 * æ—¥å¿—å™¨
 */
export class Logger {
  private level: LogLevel;
  private spinner?: Ora;
  
  constructor(verbose: boolean = false) {
    this.level = verbose ? LogLevel.DEBUG : LogLevel.INFO;
  }
  
  /**
   * ä¿¡æ¯æ—¥å¿—ï¼ˆè“è‰²ï¼‰
   */
  info(message: string, ...args: any[]): void {
    if (this.level <= LogLevel.INFO) {
      console.log(chalk.blue('â„¹'), message, ...args);
    }
  }
  
  /**
   * è­¦å‘Šæ—¥å¿—ï¼ˆé»„è‰²ï¼‰
   */
  warn(message: string, ...args: any[]): void {
    if (this.level <= LogLevel.WARN) {
      console.log(chalk.yellow('âš '), message, ...args);
    }
  }
  
  /**
   * é”™è¯¯æ—¥å¿—ï¼ˆçº¢è‰²ï¼‰
   */
  error(message: string, ...args: any[]): void {
    if (this.level <= LogLevel.ERROR) {
      console.error(chalk.red('âœ–'), message, ...args);
    }
  }
  
  /**
   * æˆåŠŸæ—¥å¿—ï¼ˆç»¿è‰²ï¼‰
   */
  success(message: string, ...args: any[]): void {
    if (this.level <= LogLevel.INFO) {
      console.log(chalk.green('âœ”'), message, ...args);
    }
  }
  
  /**
   * è°ƒè¯•æ—¥å¿—ï¼ˆç°è‰²ï¼‰
   */
  debug(message: string, ...args: any[]): void {
    if (this.level <= LogLevel.DEBUG) {
      console.log(chalk.gray('âš™'), message, ...args);
    }
  }
  
  /**
   * å¯åŠ¨åŠ è½½åŠ¨ç”»
   */
  startSpinner(text: string): void {
    this.spinner = ora(text).start();
  }
  
  /**
   * åœæ­¢åŠ è½½åŠ¨ç”»ï¼ˆæˆåŠŸï¼‰
   */
  succeedSpinner(text?: string): void {
    this.spinner?.succeed(text);
  }
  
  /**
   * åœæ­¢åŠ è½½åŠ¨ç”»ï¼ˆå¤±è´¥ï¼‰
   */
  failSpinner(text?: string): void {
    this.spinner?.fail(text);
  }
}

// å¯¼å‡ºå…¨å±€å®ä¾‹
export const logger = new Logger();
```

**è®¾è®¡ç†ç”±**ï¼š
- ä½¿ç”¨å›¾æ ‡å’Œé¢œè‰²æé«˜å¯è¯»æ€§
- æ”¯æŒè¯¦ç»†æ¨¡å¼ï¼Œä¾¿äºè°ƒè¯•
- ora spinner æä¾›å‹å¥½çš„é•¿æ—¶é—´æ“ä½œåé¦ˆ
- å•ä¾‹æ¨¡å¼ä¾¿äºå…¨å±€ä½¿ç”¨

### 8. é”™è¯¯å¤„ç† (éœ€æ±‚ 8)

**è®¾è®¡å†³ç­–**ï¼šå®šä¹‰è‡ªå®šä¹‰é”™è¯¯ç±»ï¼Œæä¾›æ¸…æ™°çš„é”™è¯¯ä¸Šä¸‹æ–‡ã€‚


#### é”™è¯¯ç±»å®šä¹‰

```typescript
// src/utils/errors.ts

/**
 * SpecBridge åŸºç¡€é”™è¯¯ç±»
 */
export class SpecBridgeError extends Error {
  code: string;
  
  constructor(message: string, code: string) {
    super(message);
    this.name = this.constructor.name;
    this.code = code;
    Error.captureStackTrace(this, this.constructor);
  }
}

/**
 * é…ç½®æ–‡ä»¶æœªæ‰¾åˆ°é”™è¯¯
 */
export class ConfigNotFoundError extends SpecBridgeError {
  constructor(path: string) {
    super(
      `Configuration file not found: ${path}`,
      'CONFIG_NOT_FOUND'
    );
  }
}

/**
 * é…ç½®è§£æé”™è¯¯
 */
export class ConfigParseError extends SpecBridgeError {
  constructor(message: string) {
    super(
      `Failed to parse configuration: ${message}`,
      'CONFIG_PARSE_ERROR'
    );
  }
}

/**
 * è®¤è¯é”™è¯¯
 */
export class AuthenticationError extends SpecBridgeError {
  constructor(platform: string) {
    super(
      `Authentication failed for ${platform}. Please check your credentials.`,
      'AUTH_ERROR'
    );
  }
}

/**
 * API é€Ÿç‡é™åˆ¶é”™è¯¯
 */
export class RateLimitError extends SpecBridgeError {
  retryAfter?: number;
  
  constructor(platform: string, retryAfter?: number) {
    super(
      `Rate limit exceeded for ${platform}. ${retryAfter ? `Retry after ${retryAfter}s` : ''}`,
      'RATE_LIMIT_ERROR'
    );
    this.retryAfter = retryAfter;
  }
}

/**
 * é€‚é…å™¨é”™è¯¯
 */
export class AdapterError extends SpecBridgeError {
  adapterName: string;
  
  constructor(adapterName: string, message: string) {
    super(
      `Adapter '${adapterName}' error: ${message}`,
      'ADAPTER_ERROR'
    );
    this.adapterName = adapterName;
  }
}
```

**è®¾è®¡ç†ç”±**ï¼š
- ç»§æ‰¿ Error ç±»ä¿æŒæ ‡å‡†é”™è¯¯å¤„ç†å…¼å®¹æ€§
- é”™è¯¯ä»£ç ä¾¿äºç¨‹åºåŒ–å¤„ç†
- ç‰¹å®šé”™è¯¯ç±»æºå¸¦é¢å¤–ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼ˆå¦‚ retryAfterï¼‰
- æ¸…æ™°çš„é”™è¯¯æ¶ˆæ¯æé«˜ç”¨æˆ·ä½“éªŒ

### 9. TypeScript é…ç½® (éœ€æ±‚ 9)

**è®¾è®¡å†³ç­–**ï¼šä½¿ç”¨ä¸¥æ ¼çš„ TypeScript é…ç½®ç¡®ä¿ä»£ç è´¨é‡ã€‚

#### tsconfig.json

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "CommonJS",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "**/*.test.ts"]
}
```

**è®¾è®¡ç†ç”±**ï¼š
- strict æ¨¡å¼å¯ç”¨æ‰€æœ‰ä¸¥æ ¼ç±»å‹æ£€æŸ¥
- ES2020 ç›®æ ‡æ”¯æŒç°ä»£ JavaScript ç‰¹æ€§
- CommonJS æ¨¡å—ç³»ç»Ÿå…¼å®¹ Node.js
- æºæ˜ å°„å’Œå£°æ˜æ–‡ä»¶ä¾¿äºè°ƒè¯•å’Œç±»å‹æç¤º
- è·¯å¾„åˆ«åç®€åŒ–å¯¼å…¥è¯­å¥

### 10. æ–‡ä»¶å·¥å…·å‡½æ•° (éœ€æ±‚ 10)

**è®¾è®¡å†³ç­–**ï¼šå°è£…å¸¸ç”¨æ–‡ä»¶æ“ä½œï¼Œæä¾›ç»Ÿä¸€çš„é”™è¯¯å¤„ç†ã€‚

#### æ–‡ä»¶å·¥å…·å®ç°

```typescript
// src/utils/file.ts
import { promises as fs } from 'fs';
import * as path from 'path';
import * as yaml from 'yaml';

/**
 * æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
 */
export async function fileExists(filePath: string): Promise<boolean> {
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
}

/**
 * è¯»å–æ–‡ä»¶å†…å®¹
 */
export async function readFile(filePath: string): Promise<string> {
  try {
    return await fs.readFile(filePath, 'utf-8');
  } catch (error) {
    throw new Error(`Failed to read file ${filePath}: ${error.message}`);
  }
}

/**
 * å†™å…¥æ–‡ä»¶å†…å®¹
 */
export async function writeFile(filePath: string, content: string): Promise<void> {
  try {
    const dir = path.dirname(filePath);
    await fs.mkdir(dir, { recursive: true });
    await fs.writeFile(filePath, content, 'utf-8');
  } catch (error) {
    throw new Error(`Failed to write file ${filePath}: ${error.message}`);
  }
}

/**
 * è¯»å– YAML æ–‡ä»¶
 */
export async function readYaml<T = any>(filePath: string): Promise<T> {
  try {
    const content = await readFile(filePath);
    return yaml.parse(content) as T;
  } catch (error) {
    throw new Error(`Failed to parse YAML file ${filePath}: ${error.message}`);
  }
}

/**
 * å†™å…¥ YAML æ–‡ä»¶
 */
export async function writeYaml(filePath: string, data: any): Promise<void> {
  try {
    const content = yaml.stringify(data);
    await writeFile(filePath, content);
  } catch (error) {
    throw new Error(`Failed to write YAML file ${filePath}: ${error.message}`);
  }
}

/**
 * ç¡®ä¿ç›®å½•å­˜åœ¨
 */
export async function ensureDir(dirPath: string): Promise<void> {
  await fs.mkdir(dirPath, { recursive: true });
}
```

**è®¾è®¡ç†ç”±**ï¼š
- ä½¿ç”¨ async/await ä¿æŒä»£ç ç®€æ´
- ç»Ÿä¸€çš„é”™è¯¯å¤„ç†å’Œæ¶ˆæ¯æ ¼å¼
- è‡ªåŠ¨åˆ›å»ºç›®å½•é¿å…å†™å…¥å¤±è´¥
- YAML å·¥å…·å‡½æ•°ç®€åŒ–é…ç½®æ–‡ä»¶æ“ä½œ

### 11. CLI å…¥å£ç‚¹ (éœ€æ±‚ 11)

**è®¾è®¡å†³ç­–**ï¼šæä¾›å¥å£®çš„ CLI å…¥å£ï¼ŒåŒ…å«å®Œå–„çš„é”™è¯¯å¤„ç†ã€‚


#### CLI å…¥å£å®ç°

```typescript
// src/index.ts
#!/usr/bin/env node

import { Command } from 'commander';
import { initCommand } from './cli/commands/init';
import { syncCommand } from './cli/commands/sync';
import { statusCommand } from './cli/commands/status';
import { logger } from './utils/logger';
import {
  SpecBridgeError,
  ConfigNotFoundError,
  AuthenticationError,
  RateLimitError
} from './utils/errors';

const program = new Command();

program
  .name('specbridge')
  .description('AI-driven spec to project management platform sync tool')
  .version('0.1.0')
  .option('-v, --verbose', 'Enable verbose logging');

// æ³¨å†Œå‘½ä»¤
program.addCommand(initCommand);
program.addCommand(syncCommand);
program.addCommand(statusCommand);

// æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯ï¼ˆæ— å‘½ä»¤æ—¶ï¼‰
if (process.argv.length === 2) {
  program.help();
}

// å…¨å±€é”™è¯¯å¤„ç†
function handleError(error: Error): void {
  if (error instanceof ConfigNotFoundError) {
    logger.error('Configuration file not found.');
    logger.info('Run "specbridge init" to create a configuration file.');
  } else if (error instanceof AuthenticationError) {
    logger.error(error.message);
    logger.info('Please check your API tokens in the configuration file.');
  } else if (error instanceof RateLimitError) {
    logger.error(error.message);
    if (error.retryAfter) {
      logger.info(`Please wait ${error.retryAfter} seconds before retrying.`);
    }
  } else if (error instanceof SpecBridgeError) {
    logger.error(`[${error.code}] ${error.message}`);
  } else {
    logger.error('An unexpected error occurred:', error.message);
    if (program.opts().verbose) {
      console.error(error.stack);
    }
  }
}

// æ•è·æœªå¤„ç†çš„å¼‚å¸¸
process.on('unhandledRejection', (error: Error) => {
  handleError(error);
  process.exit(1);
});

process.on('uncaughtException', (error: Error) => {
  handleError(error);
  process.exit(1);
});

// è§£æå‘½ä»¤
try {
  program.parse(process.argv);
} catch (error) {
  handleError(error as Error);
  process.exit(1);
}
```

**è®¾è®¡ç†ç”±**ï¼š
- shebang æ”¯æŒç›´æ¥æ‰§è¡Œ
- æ— å‘½ä»¤æ—¶æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯
- å…¨å±€é”™è¯¯å¤„ç†æä¾›å‹å¥½çš„é”™è¯¯æ¶ˆæ¯
- æ•è·æœªå¤„ç†çš„å¼‚å¸¸é¿å…ç¨‹åºå´©æºƒ
- è¯¦ç»†æ¨¡å¼ä¸‹æ˜¾ç¤ºå †æ ˆè·Ÿè¸ª

### 12. ä»£ç è´¨é‡æ ‡å‡† (éœ€æ±‚ 12)

**è®¾è®¡å†³ç­–**ï¼šä½¿ç”¨ ESLint å’Œ Prettier ç¡®ä¿ä»£ç è´¨é‡å’Œä¸€è‡´æ€§ã€‚

#### ESLint é…ç½®

```json
// .eslintrc.json
{
  "parser": "@typescript-eslint/parser",
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended"
  ],
  "parserOptions": {
    "ecmaVersion": 2020,
    "sourceType": "module"
  },
  "rules": {
    "@typescript-eslint/explicit-function-return-type": "error",
    "@typescript-eslint/no-explicit-any": "warn",
    "@typescript-eslint/no-unused-vars": "error",
    "no-console": "off"
  }
}
```

#### Prettier é…ç½®

```json
// .prettierrc
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 100,
  "tabWidth": 2
}
```

#### å‘½åè§„èŒƒ

- **æ–‡ä»¶å**ï¼škebab-caseï¼ˆå¦‚ `sync-engine.ts`ï¼‰
- **ç±»å**ï¼šPascalCaseï¼ˆå¦‚ `SyncEngine`ï¼‰
- **æ¥å£å**ï¼šPascalCaseï¼Œä¸ä½¿ç”¨ I å‰ç¼€ï¼ˆå¦‚ `SourceAdapter`ï¼‰
- **å‡½æ•°/å˜é‡**ï¼šcamelCaseï¼ˆå¦‚ `syncTasks`ï¼‰
- **å¸¸é‡**ï¼šUPPER_SNAKE_CASEï¼ˆå¦‚ `MAX_RETRY_COUNT`ï¼‰
- **æšä¸¾**ï¼šPascalCaseï¼Œæˆå‘˜ UPPER_SNAKE_CASEï¼ˆå¦‚ `TaskStatus.IN_PROGRESS`ï¼‰

**è®¾è®¡ç†ç”±**ï¼š
- è‡ªåŠ¨åŒ–ä»£ç æ£€æŸ¥å‡å°‘äººå·¥å®¡æŸ¥è´Ÿæ‹…
- ç»Ÿä¸€çš„ä»£ç é£æ ¼æé«˜å¯è¯»æ€§
- æ˜ç¡®çš„å‘½åè§„èŒƒé¿å…æ··æ·†

## Kiro æºé€‚é…å™¨å®ç° (éœ€æ±‚ 13)

**è®¾è®¡å†³ç­–**ï¼šå®ç° Kiro è§„æ ¼æ–‡æ¡£çš„å®Œæ•´è§£æé€»è¾‘ã€‚

### Kiro è§„æ ¼æ–‡ä»¶ç»“æ„

```
.kiro/specs/feature-name/
â”œâ”€â”€ requirements.md  # éœ€æ±‚æ–‡æ¡£
â”œâ”€â”€ design.md        # è®¾è®¡æ–‡æ¡£
â””â”€â”€ tasks.md         # ä»»åŠ¡åˆ—è¡¨
```

### é€‚é…å™¨å®ç°

```typescript
// src/adapters/source/kiro.ts
import * as path from 'path';
import matter from 'gray-matter';
import { BaseSourceAdapter } from './base';
import { SpecData, Requirement, Task, Design, TaskStatus } from '../../core/models';
import { fileExists, readFile } from '../../utils/file';
import { AdapterError } from '../../utils/errors';

export class KiroAdapter extends BaseSourceAdapter {
  name = 'kiro';
  
  /**
   * æ£€æµ‹æ˜¯å¦ä¸º Kiro è§„æ ¼ç›®å½•
   */
  detect(specPath: string): boolean {
    // æ£€æŸ¥æ˜¯å¦å­˜åœ¨ .kiro/specs ç›®å½•
    const kiroPath = path.join(specPath, '.kiro', 'specs');
    return fileExists(kiroPath);
  }
  
  /**
   * è§£æ Kiro è§„æ ¼æ–‡æ¡£
   * @param specPath è§„æ ¼ç›®å½•è·¯å¾„ï¼ˆå¦‚ .kiro/specs/user-authenticationï¼‰
   */
  async parse(specPath: string): Promise<SpecData> {
    try {
      const specName = path.basename(specPath);
      
      // è¯»å–ä¸‰ä¸ªæ–‡ä»¶
      const requirementsPath = path.join(specPath, 'requirements.md');
      const designPath = path.join(specPath, 'design.md');
      const tasksPath = path.join(specPath, 'tasks.md');
      
      // è§£æéœ€æ±‚
      const requirements = await this.parseRequirements(requirementsPath);
      
      // è§£æè®¾è®¡
      const design = await this.parseDesign(designPath);
      
      // è§£æä»»åŠ¡
      const tasks = await this.parseTasks(tasksPath);
      
      // æ„å»º SpecData
      const specData: SpecData = {
        meta: {
          name: specName,
          version: '1.0.0',
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        },
        requirements,
        design,
        tasks
      };
      
      this.validateSpecData(specData);
      return specData;
      
    } catch (error) {
      throw new AdapterError(this.name, `Failed to parse Kiro spec: ${error.message}`);
    }
  }
  
  /**
   * è§£æ requirements.md
   */
  private async parseRequirements(filePath: string): Promise<Requirement[]> {
    if (!await fileExists(filePath)) {
      return [];
    }
    
    const content = await readFile(filePath);
    const { data: frontmatter, content: markdown } = matter(content);
    
    const requirements: Requirement[] = [];
    
    // ä½¿ç”¨æ­£åˆ™åŒ¹é…éœ€æ±‚ç« èŠ‚
    const reqPattern = /###?\s+éœ€æ±‚\s+(\d+)[ï¼š:]\s*(.+?)$/gm;
    let match;
    
    while ((match = reqPattern.exec(markdown)) !== null) {
      const id = `req-${match[1]}`;
      const title = match[2].trim();
      
      // æå–æè¿°ï¼ˆä¸‹ä¸€æ®µå†…å®¹ï¼‰
      const startIndex = match.index + match[0].length;
      const nextHeading = markdown.indexOf('###', startIndex);
      const description = markdown
        .substring(startIndex, nextHeading > 0 ? nextHeading : undefined)
        .trim();
      
      requirements.push({
        id,
        title,
        description,
        priority: frontmatter.priority,
        labels: frontmatter.labels || []
      });
    }
    
    return requirements;
  }
  
  /**
   * è§£æ design.md
   */
  private async parseDesign(filePath: string): Promise<Design | undefined> {
    if (!await fileExists(filePath)) {
      return undefined;
    }
    
    const content = await readFile(filePath);
    const { content: markdown } = matter(content);
    
    return {
      content: markdown
    };
  }
  
  /**
   * è§£æ tasks.md
   */
  private async parseTasks(filePath: string): Promise<Task[]> {
    if (!await fileExists(filePath)) {
      return [];
    }
    
    const content = await readFile(filePath);
    const tasks: Task[] = [];
    
    // åŒ¹é…ä»»åŠ¡è¡Œï¼š- [ ] 1.1 ä»»åŠ¡æ ‡é¢˜ (@assignee)
    const taskPattern = /^-\s+\[([ x-])\]\s+(\d+(?:\.\d+)?)\s+(.+?)(?:\s+\(@(\w+)\))?$/gm;
    let match;
    
    while ((match = taskPattern.exec(content)) !== null) {
      const statusChar = match[1];
      const taskId = match[2];
      const title = match[3].trim();
      const assignee = match[4];
      
      // æ˜ å°„çŠ¶æ€
      let status: TaskStatus;
      if (statusChar === 'x') {
        status = TaskStatus.DONE;
      } else if (statusChar === '-') {
        status = TaskStatus.IN_PROGRESS;
      } else {
        status = TaskStatus.TODO;
      }
      
      tasks.push({
        id: taskId,
        title,
        status,
        assignee
      });
    }
    
    return tasks;
  }
}
```

**è®¾è®¡ç†ç”±**ï¼š
- ä½¿ç”¨ gray-matter è§£æ frontmatter å…ƒæ•°æ®
- æ­£åˆ™è¡¨è¾¾å¼æå–ç»“æ„åŒ–å†…å®¹
- æ”¯æŒä»»åŠ¡çŠ¶æ€æ˜ å°„ï¼ˆ[ ] â†’ todo, [x] â†’ done, [-] â†’ in_progressï¼‰
- æ”¯æŒä»»åŠ¡è´Ÿè´£äººæå–ï¼ˆ@usernameï¼‰
- é”™è¯¯å¤„ç†åŒ…è£…ä¸º AdapterError

## GitHub ç›®æ ‡é€‚é…å™¨å®ç° (éœ€æ±‚ 14-15)

**è®¾è®¡å†³ç­–**ï¼šæ”¯æŒä¸¤ç§è®¤è¯æ–¹å¼ï¼ˆAPI token å’Œ gh CLIï¼‰ï¼Œå®ç°å®Œæ•´çš„ Issue åŒæ­¥é€»è¾‘ã€‚


### GitHub é€‚é…å™¨å®ç°

```typescript
// src/adapters/target/github.ts
import { Octokit } from '@octokit/rest';
import { exec } from 'child_process';
import { promisify } from 'util';
import { BaseTargetAdapter } from './base';
import {
  Requirement,
  Task,
  Design,
  SyncResult,
  TaskStatus,
  SyncChange
} from '../../core/models';
import { AuthenticationError, AdapterError } from '../../utils/errors';

const execAsync = promisify(exec);

/**
 * GitHub é€‚é…å™¨é…ç½®
 */
interface GitHubConfig {
  owner: string;           // ä»“åº“æ‰€æœ‰è€…
  repo: string;            // ä»“åº“åç§°
  token?: string;          // GitHub API token
  authMethod: 'token' | 'gh-cli';  // è®¤è¯æ–¹å¼
  addComments?: boolean;   // æ˜¯å¦æ·»åŠ åŒæ­¥è¯„è®º
}

/**
 * GitHub é€‚é…å™¨
 */
export class GitHubAdapter extends BaseTargetAdapter {
  name = 'github';
  private octokit?: Octokit;
  private ghConfig?: GitHubConfig;
  
  /**
   * åˆå§‹åŒ–é€‚é…å™¨
   */
  async init(config: GitHubConfig): Promise<void> {
    this.ghConfig = config;
    
    if (config.authMethod === 'token') {
      if (!config.token) {
        throw new AuthenticationError('GitHub: token is required');
      }
      this.octokit = new Octokit({ auth: config.token });
    } else if (config.authMethod === 'gh-cli') {
      // æ£€æŸ¥ gh CLI æ˜¯å¦å¯ç”¨
      try {
        await execAsync('gh --version');
      } catch {
        throw new AdapterError(
          this.name,
          'gh CLI is not installed or not in PATH'
        );
      }
    }
    
    // éªŒè¯ä»“åº“è®¿é—®æƒé™
    await this.validateAccess();
  }
  
  /**
   * éªŒè¯ä»“åº“è®¿é—®æƒé™
   */
  private async validateAccess(): Promise<void> {
    try {
      if (this.octokit) {
        await this.octokit.repos.get({
          owner: this.ghConfig!.owner,
          repo: this.ghConfig!.repo
        });
      } else {
        await execAsync(
          `gh repo view ${this.ghConfig!.owner}/${this.ghConfig!.repo}`
        );
      }
    } catch (error) {
      throw new AuthenticationError('GitHub: failed to access repository');
    }
  }
  
  /**
   * åŒæ­¥éœ€æ±‚ï¼ˆå¯é€‰åŠŸèƒ½ï¼‰
   */
  async syncRequirements(requirements: Requirement[]): Promise<SyncResult> {
    const result = this.createSyncResult();
    
    for (const req of requirements) {
      try {
        const existingIssue = await this.findIssueByLabel(
          `specbridge:req-id:${req.id}`
        );
        
        if (existingIssue) {
          // æ›´æ–°ç°æœ‰ Issue
          await this.updateIssue(existingIssue.number, {
            title: req.title,
            body: this.formatRequirementBody(req),
            labels: this.buildLabels(req.labels, `specbridge:req-id:${req.id}`)
          });
          result.updated++;
          result.changes.push({
            timestamp: new Date().toISOString(),
            action: 'updated',
            itemType: 'requirement',
            itemId: req.id
          });
        } else {
          // åˆ›å»ºæ–° Issue
          const issue = await this.createIssue({
            title: req.title,
            body: this.formatRequirementBody(req),
            labels: this.buildLabels(req.labels, `specbridge:req-id:${req.id}`)
          });
          req.syncId = `#${issue.number}`;
          result.created++;
          result.changes.push({
            timestamp: new Date().toISOString(),
            action: 'created',
            itemType: 'requirement',
            itemId: req.id
          });
        }
      } catch (error) {
        result.failed++;
        result.errors?.push(`Failed to sync requirement ${req.id}: ${error.message}`);
      }
    }
    
    result.success = result.failed === 0;
    return result;
  }
  
  /**
   * åŒæ­¥ä»»åŠ¡
   */
  async syncTasks(tasks: Task[]): Promise<SyncResult> {
    const result = this.createSyncResult();
    
    for (const task of tasks) {
      try {
        const label = `specbridge:task-id:${task.id}`;
        const existingIssue = await this.findIssueByLabel(label);
        
        if (existingIssue) {
          // æ£€æµ‹å˜æ›´
          const changes = this.detectTaskChanges(existingIssue, task);
          
          if (changes.length > 0) {
            // æ›´æ–° Issue
            await this.updateIssue(existingIssue.number, {
              title: task.title,
              body: this.formatTaskBody(task),
              state: task.status === TaskStatus.DONE ? 'closed' : 'open',
              assignees: task.assignee ? [task.assignee] : undefined,
              labels: this.buildLabels(task.labels, label)
            });
            
            // æ·»åŠ è¯„è®ºè®°å½•å˜æ›´
            if (this.ghConfig?.addComments) {
              await this.addComment(
                existingIssue.number,
                this.formatChangeComment(changes)
              );
            }
            
            result.updated++;
            result.changes.push({
              timestamp: new Date().toISOString(),
              action: 'updated',
              itemType: 'task',
              itemId: task.id,
              changes
            });
          }
        } else {
          // åˆ›å»ºæ–° Issue
          const issue = await this.createIssue({
            title: task.title,
            body: this.formatTaskBody(task),
            labels: this.buildLabels(task.labels, label),
            assignees: task.assignee ? [task.assignee] : undefined
          });
          
          task.syncId = `#${issue.number}`;
          result.created++;
          result.changes.push({
            timestamp: new Date().toISOString(),
            action: 'created',
            itemType: 'task',
            itemId: task.id
          });
        }
      } catch (error) {
        result.failed++;
        result.errors?.push(`Failed to sync task ${task.id}: ${error.message}`);
      }
    }
    
    result.success = result.failed === 0;
    return result;
  }
  
  /**
   * åŒæ­¥è®¾è®¡æ–‡æ¡£ï¼ˆå¯é€‰ï¼‰
   */
  async syncDesign(design: Design): Promise<SyncResult> {
    // è®¾è®¡æ–‡æ¡£åŒæ­¥ä¸ºå¯é€‰åŠŸèƒ½ï¼Œå¯ä»¥åˆ›å»ºä¸€ä¸ªç‰¹æ®Šçš„ Issue
    const result = this.createSyncResult();
    // å®ç°é€»è¾‘...
    return result;
  }
  
  /**
   * è·å–ä»»åŠ¡çŠ¶æ€
   */
  async getTaskStatus(taskId: string): Promise<TaskStatus> {
    const label = `specbridge:task-id:${taskId}`;
    const issue = await this.findIssueByLabel(label);
    
    if (!issue) {
      throw new AdapterError(this.name, `Task ${taskId} not found`);
    }
    
    return issue.state === 'closed' ? TaskStatus.DONE : TaskStatus.TODO;
  }
  
  /**
   * æŸ¥æ‰¾å¸¦æœ‰ç‰¹å®šæ ‡ç­¾çš„ Issue
   */
  private async findIssueByLabel(label: string): Promise<any | null> {
    if (this.octokit) {
      const { data } = await this.octokit.issues.listForRepo({
        owner: this.ghConfig!.owner,
        repo: this.ghConfig!.repo,
        labels: label,
        state: 'all'
      });
      return data[0] || null;
    } else {
      // ä½¿ç”¨ gh CLI
      const { stdout } = await execAsync(
        `gh issue list --repo ${this.ghConfig!.owner}/${this.ghConfig!.repo} --label "${label}" --state all --json number,title,state,body`
      );
      const issues = JSON.parse(stdout);
      return issues[0] || null;
    }
  }
  
  /**
   * åˆ›å»º Issue
   */
  private async createIssue(options: {
    title: string;
    body: string;
    labels?: string[];
    assignees?: string[];
  }): Promise<any> {
    if (this.octokit) {
      const { data } = await this.octokit.issues.create({
        owner: this.ghConfig!.owner,
        repo: this.ghConfig!.repo,
        ...options
      });
      return data;
    } else {
      // ä½¿ç”¨ gh CLI
      const labelsArg = options.labels?.map(l => `--label "${l}"`).join(' ') || '';
      const assigneesArg = options.assignees?.map(a => `--assignee ${a}`).join(' ') || '';
      
      const { stdout } = await execAsync(
        `gh issue create --repo ${this.ghConfig!.owner}/${this.ghConfig!.repo} --title "${options.title}" --body "${options.body}" ${labelsArg} ${assigneesArg}`
      );
      
      // æå– Issue ç¼–å·
      const match = stdout.match(/#(\d+)/);
      return { number: match ? parseInt(match[1]) : 0 };
    }
  }
  
  /**
   * æ›´æ–° Issue
   */
  private async updateIssue(issueNumber: number, options: any): Promise<void> {
    if (this.octokit) {
      await this.octokit.issues.update({
        owner: this.ghConfig!.owner,
        repo: this.ghConfig!.repo,
        issue_number: issueNumber,
        ...options
      });
    } else {
      // ä½¿ç”¨ gh CLI
      const args: string[] = [];
      if (options.title) args.push(`--title "${options.title}"`);
      if (options.body) args.push(`--body "${options.body}"`);
      if (options.state) args.push(`--state ${options.state}`);
      
      await execAsync(
        `gh issue edit ${issueNumber} --repo ${this.ghConfig!.owner}/${this.ghConfig!.repo} ${args.join(' ')}`
      );
    }
  }
  
  /**
   * æ·»åŠ è¯„è®º
   */
  private async addComment(issueNumber: number, body: string): Promise<void> {
    if (this.octokit) {
      await this.octokit.issues.createComment({
        owner: this.ghConfig!.owner,
        repo: this.ghConfig!.repo,
        issue_number: issueNumber,
        body
      });
    } else {
      await execAsync(
        `gh issue comment ${issueNumber} --repo ${this.ghConfig!.owner}/${this.ghConfig!.repo} --body "${body}"`
      );
    }
  }
  
  /**
   * æ£€æµ‹ä»»åŠ¡å˜æ›´
   */
  private detectTaskChanges(existingIssue: any, task: Task): Array<{
    field: string;
    oldValue: any;
    newValue: any;
  }> {
    const changes: Array<{ field: string; oldValue: any; newValue: any }> = [];
    
    if (existingIssue.title !== task.title) {
      changes.push({
        field: 'title',
        oldValue: existingIssue.title,
        newValue: task.title
      });
    }
    
    const expectedState = task.status === TaskStatus.DONE ? 'closed' : 'open';
    if (existingIssue.state !== expectedState) {
      changes.push({
        field: 'status',
        oldValue: existingIssue.state,
        newValue: expectedState
      });
    }
    
    return changes;
  }
  
  /**
   * æ ¼å¼åŒ–ä»»åŠ¡æ­£æ–‡
   */
  private formatTaskBody(task: Task): string {
    let body = task.description || '';
    body += '\n\n---\n';
    body += `**çŠ¶æ€**: ${task.status}\n`;
    if (task.assignee) body += `**è´Ÿè´£äºº**: @${task.assignee}\n`;
    if (task.parentId) body += `**çˆ¶ä»»åŠ¡**: ${task.parentId}\n`;
    body += '\n_ğŸ”„ ç”± SpecBridge åŒæ­¥_';
    return body;
  }
  
  /**
   * æ ¼å¼åŒ–éœ€æ±‚æ­£æ–‡
   */
  private formatRequirementBody(req: Requirement): string {
    let body = req.description;
    body += '\n\n---\n';
    if (req.priority) body += `**ä¼˜å…ˆçº§**: ${req.priority}\n`;
    body += '\n_ğŸ”„ ç”± SpecBridge åŒæ­¥_';
    return body;
  }
  
  /**
   * æ„å»ºæ ‡ç­¾æ•°ç»„
   */
  private buildLabels(customLabels?: string[], syncLabel?: string): string[] {
    const labels = ['specbridge'];
    if (syncLabel) labels.push(syncLabel);
    if (customLabels) labels.push(...customLabels);
    return labels;
  }
  
  /**
   * æ ¼å¼åŒ–å˜æ›´è¯„è®º
   */
  private formatChangeComment(changes: Array<{
    field: string;
    oldValue: any;
    newValue: any;
  }>): string {
    let comment = 'ğŸ”„ **SpecBridge åŒæ­¥æ›´æ–°**\n\n';
    comment += `_åŒæ­¥æ—¶é—´: ${new Date().toISOString()}_\n\n`;
    comment += '**å˜æ›´å†…å®¹**:\n';
    
    for (const change of changes) {
      comment += `- **${change.field}**: \`${change.oldValue}\` â†’ \`${change.newValue}\`\n`;
    }
    
    return comment;
  }
}
```

**è®¾è®¡ç†ç”±**ï¼š
- æ”¯æŒä¸¤ç§è®¤è¯æ–¹å¼æé«˜çµæ´»æ€§
- ä½¿ç”¨è‡ªå®šä¹‰æ ‡ç­¾ï¼ˆspecbridge:task-id:xxxï¼‰è¿½è¸ªåŒæ­¥çŠ¶æ€
- å˜æ›´æ£€æµ‹é¿å…ä¸å¿…è¦çš„ API è°ƒç”¨
- è¯„è®ºåŠŸèƒ½æä¾›è¯¦ç»†çš„åŒæ­¥å†å²
- é”™è¯¯å¤„ç†ç¡®ä¿å•ä¸ªä»»åŠ¡å¤±è´¥ä¸å½±å“æ•´ä½“åŒæ­¥

## åŒæ­¥ç²’åº¦æ§åˆ¶ (éœ€æ±‚ 16)

**è®¾è®¡å†³ç­–**ï¼šé€šè¿‡ CLI é€‰é¡¹æ§åˆ¶åŒæ­¥èŒƒå›´ã€‚


### åŒæ­¥ç²’åº¦å®ç°

```typescript
// src/cli/commands/sync.ts
import { Command } from 'commander';
import { loadConfig } from '../../core/config';
import { SyncEngine } from '../../core/sync-engine';
import { KiroAdapter } from '../../adapters/source/kiro';
import { GitHubAdapter } from '../../adapters/target/github';
import { logger } from '../../utils/logger';

export const syncCommand = new Command('sync')
  .description('Sync specs to project management platforms')
  .option('--scope <type>', 'Sync scope: all|requirements|tasks|single', 'all')
  .option('--id <id>', 'Item ID when scope is single')
  .option('--dry-run', 'Simulate sync without making changes')
  .action(async (options) => {
    try {
      logger.startSpinner('Loading configuration...');
      const config = await loadConfig();
      logger.succeedSpinner('Configuration loaded');
      
      // åˆå§‹åŒ–æºé€‚é…å™¨
      const sourceAdapter = new KiroAdapter();
      logger.info(`Using source adapter: ${sourceAdapter.name}`);
      
      // è§£æè§„æ ¼
      logger.startSpinner('Parsing spec files...');
      const specData = await sourceAdapter.parse(config.source.path || '.kiro/specs');
      logger.succeedSpinner(`Parsed ${specData.tasks.length} tasks, ${specData.requirements.length} requirements`);
      
      // æ ¹æ® scope è¿‡æ»¤æ•°æ®
      const filteredData = filterByScope(specData, options.scope, options.id);
      
      // åˆå§‹åŒ–ç›®æ ‡é€‚é…å™¨
      const targetAdapters = [];
      for (const targetConfig of config.targets) {
        if (!targetConfig.enabled) continue;
        
        if (targetConfig.type === 'github') {
          const adapter = new GitHubAdapter();
          await adapter.init(targetConfig.config);
          targetAdapters.push(adapter);
        }
      }
      
      if (targetAdapters.length === 0) {
        logger.warn('No enabled target adapters found');
        return;
      }
      
      // æ‰§è¡ŒåŒæ­¥
      const syncEngine = new SyncEngine();
      logger.startSpinner('Syncing...');
      
      const results = await syncEngine.sync(
        sourceAdapter,
        targetAdapters,
        { scope: options.scope, itemId: options.id, dryRun: options.dryRun }
      );
      
      logger.succeedSpinner('Sync completed');
      
      // æ˜¾ç¤ºç»“æœ
      for (const result of results) {
        logger.success(`Created: ${result.created}, Updated: ${result.updated}, Failed: ${result.failed}`);
        
        if (options.verbose && result.changes.length > 0) {
          logger.info('Changes:');
          for (const change of result.changes) {
            logger.info(`  - ${change.action} ${change.itemType} ${change.itemId}`);
          }
        }
      }
      
    } catch (error) {
      logger.failSpinner('Sync failed');
      throw error;
    }
  });

/**
 * æ ¹æ® scope è¿‡æ»¤æ•°æ®
 */
function filterByScope(specData: SpecData, scope: string, itemId?: string): SpecData {
  const filtered = { ...specData };
  
  switch (scope) {
    case 'requirements':
      filtered.tasks = [];
      filtered.design = undefined;
      break;
    case 'tasks':
      filtered.requirements = [];
      filtered.design = undefined;
      break;
    case 'single':
      if (!itemId) {
        throw new Error('--id is required when scope is single');
      }
      filtered.requirements = specData.requirements.filter(r => r.id === itemId);
      filtered.tasks = specData.tasks.filter(t => t.id === itemId);
      filtered.design = undefined;
      break;
    case 'all':
    default:
      // ä¸è¿‡æ»¤
      break;
  }
  
  return filtered;
}
```

**è®¾è®¡ç†ç”±**ï¼š
- --scope é€‰é¡¹æä¾›çµæ´»çš„åŒæ­¥æ§åˆ¶
- --id é€‰é¡¹æ”¯æŒå•é¡¹åŒæ­¥ï¼Œä¾¿äºæµ‹è¯•å’Œå¢é‡æ›´æ–°
- --dry-run é€‰é¡¹å…è®¸é¢„è§ˆåŒæ­¥ç»“æœ
- æ¸…æ™°çš„æ—¥å¿—è¾“å‡ºæä¾›åŒæ­¥è¿›åº¦åé¦ˆ

## åŒæ­¥å˜æ›´è®°å½• (éœ€æ±‚ 17)

**è®¾è®¡å†³ç­–**ï¼šåœ¨ SyncResult ä¸­è¯¦ç»†è®°å½•æ¯æ¬¡åŒæ­¥çš„å˜æ›´ã€‚

### å˜æ›´è®°å½•å®ç°

å˜æ›´è®°å½•å·²é›†æˆåœ¨ SyncResult æ¥å£å’Œ GitHub é€‚é…å™¨çš„ detectTaskChanges æ–¹æ³•ä¸­ã€‚æ¯æ¬¡åŒæ­¥æ“ä½œéƒ½ä¼šï¼š

1. è®°å½•æ“ä½œç±»å‹ï¼ˆcreated/updated/closedï¼‰
2. è®°å½•é¡¹ç›®ç±»å‹ï¼ˆrequirement/task/designï¼‰
3. è®°å½•é¡¹ç›® ID
4. è®°å½•å…·ä½“å˜æ›´å­—æ®µï¼ˆfieldã€oldValueã€newValueï¼‰

ç¤ºä¾‹å˜æ›´è®°å½•ï¼š

```json
{
  "timestamp": "2026-01-16T12:00:00Z",
  "action": "updated",
  "itemType": "task",
  "itemId": "1.1",
  "changes": [
    {
      "field": "title",
      "oldValue": "åˆ›å»ºç™»å½• API",
      "newValue": "å®ç°ç™»å½• API ç«¯ç‚¹"
    },
    {
      "field": "status",
      "oldValue": "open",
      "newValue": "closed"
    }
  ]
}
```

## GitHub Issue è¯„è®ºåŒæ­¥ (éœ€æ±‚ 18)

**è®¾è®¡å†³ç­–**ï¼šåœ¨é…ç½®ä¸­æä¾› addComments é€‰é¡¹æ§åˆ¶è¯„è®ºåŠŸèƒ½ã€‚

### è¯„è®ºåŠŸèƒ½å®ç°

è¯„è®ºåŠŸèƒ½å·²åœ¨ GitHubAdapter çš„ syncTasks æ–¹æ³•ä¸­å®ç°ï¼š

```typescript
// æ·»åŠ è¯„è®ºè®°å½•å˜æ›´
if (this.ghConfig?.addComments) {
  await this.addComment(
    existingIssue.number,
    this.formatChangeComment(changes)
  );
}
```

è¯„è®ºæ ¼å¼ç¤ºä¾‹ï¼š

```markdown
ğŸ”„ **SpecBridge åŒæ­¥æ›´æ–°**

_åŒæ­¥æ—¶é—´: 2026-01-16T12:00:00Z_

**å˜æ›´å†…å®¹**:
- **title**: `åˆ›å»ºç™»å½• API` â†’ `å®ç°ç™»å½• API ç«¯ç‚¹`
- **status**: `open` â†’ `closed`
```

**è®¾è®¡ç†ç”±**ï¼š
- å¯é…ç½®çš„è¯„è®ºåŠŸèƒ½é¿å…è¿‡å¤šé€šçŸ¥
- æ¸…æ™°çš„æ ¼å¼ä¾¿äºè¿½è¸ªå˜æ›´å†å²
- æ—¶é—´æˆ³æä¾›å®¡è®¡è¿½è¸ª

## ä»»åŠ¡å†…å®¹æ›´æ–°åŒæ­¥ (éœ€æ±‚ 19)

**è®¾è®¡å†³ç­–**ï¼šåœ¨ detectTaskChanges æ–¹æ³•ä¸­æ£€æµ‹æ‰€æœ‰å­—æ®µå˜æ›´ã€‚

### å†…å®¹æ›´æ–°æ£€æµ‹

```typescript
private detectTaskChanges(existingIssue: any, task: Task): Array<{
  field: string;
  oldValue: any;
  newValue: any;
}> {
  const changes: Array<{ field: string; oldValue: any; newValue: any }> = [];
  
  // æ£€æµ‹æ ‡é¢˜å˜æ›´
  if (existingIssue.title !== task.title) {
    changes.push({
      field: 'title',
      oldValue: existingIssue.title,
      newValue: task.title
    });
  }
  
  // æ£€æµ‹æè¿°å˜æ›´
  const expectedBody = this.formatTaskBody(task);
  if (existingIssue.body !== expectedBody) {
    changes.push({
      field: 'description',
      oldValue: existingIssue.body,
      newValue: expectedBody
    });
  }
  
  // æ£€æµ‹çŠ¶æ€å˜æ›´
  const expectedState = task.status === TaskStatus.DONE ? 'closed' : 'open';
  if (existingIssue.state !== expectedState) {
    changes.push({
      field: 'status',
      oldValue: existingIssue.state,
      newValue: expectedState
    });
  }
  
  // æ£€æµ‹è´Ÿè´£äººå˜æ›´
  const currentAssignee = existingIssue.assignees?.[0]?.login;
  if (currentAssignee !== task.assignee) {
    changes.push({
      field: 'assignee',
      oldValue: currentAssignee,
      newValue: task.assignee
    });
  }
  
  // æ£€æµ‹æ ‡ç­¾å˜æ›´
  const currentLabels = existingIssue.labels.map(l => l.name);
  const expectedLabels = this.buildLabels(task.labels, `specbridge:task-id:${task.id}`);
  if (JSON.stringify(currentLabels.sort()) !== JSON.stringify(expectedLabels.sort())) {
    changes.push({
      field: 'labels',
      oldValue: currentLabels,
      newValue: expectedLabels
    });
  }
  
  return changes;
}
```

**è®¾è®¡ç†ç”±**ï¼š
- å…¨é¢çš„å­—æ®µæ£€æµ‹ç¡®ä¿åŒæ­¥å®Œæ•´æ€§
- ä»…æ›´æ–°å˜æ›´å­—æ®µå‡å°‘ API è°ƒç”¨
- è¯¦ç»†çš„å˜æ›´è®°å½•ä¾¿äºè°ƒè¯•

## åŒæ­¥çŠ¶æ€æŒä¹…åŒ– (éœ€æ±‚ 20)

**è®¾è®¡å†³ç­–**ï¼šä½¿ç”¨æœ¬åœ° JSON æ–‡ä»¶å­˜å‚¨åŒæ­¥çŠ¶æ€æ˜ å°„ã€‚

### çŠ¶æ€æŒä¹…åŒ–å®ç°

```typescript
// src/core/sync-state.ts
import * as path from 'path';
import { readFile, writeFile, fileExists, ensureDir } from '../utils/file';

/**
 * åŒæ­¥çŠ¶æ€æ˜ å°„
 */
interface SyncStateMap {
  [taskId: string]: {
    issueNumber: number;
    platform: string;
    lastSync: string;
  };
}

/**
 * åŒæ­¥çŠ¶æ€ç®¡ç†å™¨
 */
export class SyncStateManager {
  private stateFilePath: string;
  private state: SyncStateMap = {};
  
  constructor(projectRoot: string = process.cwd()) {
    this.stateFilePath = path.join(projectRoot, '.specbridge', 'sync-state.json');
  }
  
  /**
   * åŠ è½½åŒæ­¥çŠ¶æ€
   */
  async load(): Promise<void> {
    if (await fileExists(this.stateFilePath)) {
      const content = await readFile(this.stateFilePath);
      this.state = JSON.parse(content);
    }
  }
  
  /**
   * ä¿å­˜åŒæ­¥çŠ¶æ€
   */
  async save(): Promise<void> {
    await ensureDir(path.dirname(this.stateFilePath));
    await writeFile(this.stateFilePath, JSON.stringify(this.state, null, 2));
  }
  
  /**
   * è·å–ä»»åŠ¡çš„åŒæ­¥ ID
   */
  getSyncId(taskId: string, platform: string): number | undefined {
    const entry = this.state[taskId];
    return entry?.platform === platform ? entry.issueNumber : undefined;
  }
  
  /**
   * è®¾ç½®ä»»åŠ¡çš„åŒæ­¥ ID
   */
  setSyncId(taskId: string, platform: string, issueNumber: number): void {
    this.state[taskId] = {
      issueNumber,
      platform,
      lastSync: new Date().toISOString()
    };
  }
  
  /**
   * åˆ é™¤ä»»åŠ¡çš„åŒæ­¥çŠ¶æ€
   */
  removeSyncId(taskId: string): void {
    delete this.state[taskId];
  }
}
```

### é›†æˆåˆ° GitHub é€‚é…å™¨

```typescript
// åœ¨ GitHubAdapter ä¸­ä½¿ç”¨ SyncStateManager
import { SyncStateManager } from '../../core/sync-state';

export class GitHubAdapter extends BaseTargetAdapter {
  private stateManager: SyncStateManager;
  
  async init(config: GitHubConfig): Promise<void> {
    // ... ç°æœ‰åˆå§‹åŒ–ä»£ç 
    this.stateManager = new SyncStateManager();
    await this.stateManager.load();
  }
  
  async syncTasks(tasks: Task[]): Promise<SyncResult> {
    // ... åŒæ­¥é€»è¾‘
    
    // ä¿å­˜åŒæ­¥çŠ¶æ€
    for (const task of tasks) {
      if (task.syncId) {
        const issueNumber = parseInt(task.syncId.replace('#', ''));
        this.stateManager.setSyncId(task.id, 'github', issueNumber);
      }
    }
    
    await this.stateManager.save();
    return result;
  }
}
```

### .gitignore å»ºè®®

åœ¨ init å‘½ä»¤ä¸­æç¤ºç”¨æˆ·æ·»åŠ åˆ° .gitignoreï¼š

```typescript
// src/cli/commands/init.ts
logger.info('Configuration created successfully!');
logger.info('');
logger.warn('Remember to add the following to your .gitignore:');
logger.info('  .specbridge/');
logger.info('  .specbridge.yaml  # if it contains sensitive tokens');
```

**è®¾è®¡ç†ç”±**ï¼š
- JSON æ ¼å¼æ˜“äºè¯»å†™å’Œè°ƒè¯•
- æœ¬åœ°å­˜å‚¨é¿å…ä¾èµ–å¤–éƒ¨æœåŠ¡
- åŒ…å« lastSync æ—¶é—´æˆ³ä¾¿äºè¿½è¸ª
- .gitignore å»ºè®®é¿å…æ•æ„Ÿä¿¡æ¯æ³„éœ²

## é¡¹ç›®ç»“æ„

æœ€ç»ˆçš„é¡¹ç›®æ–‡ä»¶ç»“æ„ï¼š

```
specbridge/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ index.ts                    # CLI å…¥å£
â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â”œâ”€â”€ models.ts              # ç»Ÿä¸€æ•°æ®æ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ sync-engine.ts         # åŒæ­¥å¼•æ“
â”‚   â”‚   â”œâ”€â”€ config.ts              # é…ç½®ç®¡ç†
â”‚   â”‚   â””â”€â”€ sync-state.ts          # åŒæ­¥çŠ¶æ€ç®¡ç†
â”‚   â”œâ”€â”€ adapters/
â”‚   â”‚   â”œâ”€â”€ source/
â”‚   â”‚   â”‚   â”œâ”€â”€ base.ts           # æºé€‚é…å™¨æ¥å£
â”‚   â”‚   â”‚   â””â”€â”€ kiro.ts           # Kiro é€‚é…å™¨å®ç°
â”‚   â”‚   â””â”€â”€ target/
â”‚   â”‚       â”œâ”€â”€ base.ts           # ç›®æ ‡é€‚é…å™¨æ¥å£
â”‚   â”‚       â””â”€â”€ github.ts         # GitHub é€‚é…å™¨å®ç°
â”‚   â”œâ”€â”€ cli/
â”‚   â”‚   â””â”€â”€ commands/
â”‚   â”‚       â”œâ”€â”€ init.ts           # init å‘½ä»¤
â”‚   â”‚       â”œâ”€â”€ sync.ts           # sync å‘½ä»¤
â”‚   â”‚       â””â”€â”€ status.ts         # status å‘½ä»¤
â”‚   â””â”€â”€ utils/
â”‚       â”œâ”€â”€ logger.ts             # æ—¥å¿—å·¥å…·
â”‚       â”œâ”€â”€ file.ts               # æ–‡ä»¶å·¥å…·
â”‚       â””â”€â”€ errors.ts             # é”™è¯¯ç±»
â”œâ”€â”€ dist/                          # ç¼–è¯‘è¾“å‡º
â”œâ”€â”€ docs/                          # æ–‡æ¡£
â”œâ”€â”€ examples/
â”‚   â””â”€â”€ .specbridge.yaml          # ç¤ºä¾‹é…ç½®
â”œâ”€â”€ .eslintrc.json                # ESLint é…ç½®
â”œâ”€â”€ .prettierrc                   # Prettier é…ç½®
â”œâ”€â”€ tsconfig.json                 # TypeScript é…ç½®
â”œâ”€â”€ package.json
â””â”€â”€ README.md
```

## æŠ€æœ¯å†³ç­–æ€»ç»“

### 1. ä¸ºä»€ä¹ˆé€‰æ‹© TypeScriptï¼Ÿ
- å¼ºç±»å‹ç³»ç»Ÿå‡å°‘è¿è¡Œæ—¶é”™è¯¯
- ä¼˜ç§€çš„ IDE æ”¯æŒæé«˜å¼€å‘æ•ˆç‡
- ä¸°å¯Œçš„ç”Ÿæ€ç³»ç»Ÿå’Œç±»å‹å®šä¹‰

### 2. ä¸ºä»€ä¹ˆä½¿ç”¨åŒé€‚é…å™¨æ¶æ„ï¼Ÿ
- è§£è€¦æºå’Œç›®æ ‡ï¼Œæé«˜å¯æ‰©å±•æ€§
- ç»Ÿä¸€æ•°æ®æ¨¡å‹ç®€åŒ–è½¬æ¢é€»è¾‘
- æ”¯æŒå¤šå¯¹å¤šåŒæ­¥åœºæ™¯

### 3. ä¸ºä»€ä¹ˆæ”¯æŒä¸¤ç§ GitHub è®¤è¯æ–¹å¼ï¼Ÿ
- API tokenï¼šé€‚åˆ CI/CD å’Œè‡ªåŠ¨åŒ–åœºæ™¯
- gh CLIï¼šé€‚åˆæœ¬åœ°å¼€å‘ï¼Œæ— éœ€ç®¡ç† token

### 4. ä¸ºä»€ä¹ˆä½¿ç”¨è‡ªå®šä¹‰æ ‡ç­¾è¿½è¸ªåŒæ­¥çŠ¶æ€ï¼Ÿ
- é¿å…ä¾èµ–å¤–éƒ¨æ•°æ®åº“
- åˆ©ç”¨å¹³å°åŸç”ŸåŠŸèƒ½
- æ”¯æŒæ‰‹åŠ¨æŸ¥è¯¢å’Œç®¡ç†

### 5. ä¸ºä»€ä¹ˆä½¿ç”¨æœ¬åœ° JSON æ–‡ä»¶å­˜å‚¨çŠ¶æ€ï¼Ÿ
- ç®€å•å¯é ï¼Œæ— éœ€é¢å¤–ä¾èµ–
- æ˜“äºè°ƒè¯•å’Œæ‰‹åŠ¨ä¿®æ”¹
- æ”¯æŒç‰ˆæœ¬æ§åˆ¶ï¼ˆå¯é€‰ï¼‰

## æ€§èƒ½è€ƒè™‘

### API è°ƒç”¨ä¼˜åŒ–
- ä½¿ç”¨æ ‡ç­¾æŸ¥è¯¢å‡å°‘ API è°ƒç”¨æ¬¡æ•°
- æ‰¹é‡æ“ä½œï¼ˆå¦‚æœå¹³å°æ”¯æŒï¼‰
- å˜æ›´æ£€æµ‹é¿å…ä¸å¿…è¦çš„æ›´æ–°

### é”™è¯¯å¤„ç†å’Œé‡è¯•
- å®ç°æŒ‡æ•°é€€é¿é‡è¯•æœºåˆ¶
- é€Ÿç‡é™åˆ¶æ£€æµ‹å’Œç­‰å¾…
- å•ä¸ªå¤±è´¥ä¸å½±å“æ•´ä½“åŒæ­¥

### å¹¶å‘æ§åˆ¶
- å¹¶è¡ŒåŒæ­¥åˆ°å¤šä¸ªç›®æ ‡å¹³å°
- é™åˆ¶å¹¶å‘ API è¯·æ±‚æ•°é‡
- ä½¿ç”¨è¿æ¥æ± ç®¡ç† HTTP è¿æ¥

## å®‰å…¨è€ƒè™‘

### å‡­è¯ç®¡ç†
- ç¯å¢ƒå˜é‡å­˜å‚¨æ•æ„Ÿä¿¡æ¯
- é…ç½®æ–‡ä»¶ä¸­ä½¿ç”¨ ${VAR} è¯­æ³•
- æç¤ºç”¨æˆ·æ·»åŠ åˆ° .gitignore

### API æƒé™
- ä½¿ç”¨æœ€å°å¿…éœ€æƒé™
- éªŒè¯ä»“åº“è®¿é—®æƒé™
- é”™è¯¯æ¶ˆæ¯ä¸æ³„éœ²æ•æ„Ÿä¿¡æ¯

### è¾“å…¥éªŒè¯
- éªŒè¯é…ç½®æ–‡ä»¶æ ¼å¼
- éªŒè¯ç”¨æˆ·è¾“å…¥å‚æ•°
- é˜²æ­¢è·¯å¾„éå†æ”»å‡»

## æµ‹è¯•ç­–ç•¥

### å•å…ƒæµ‹è¯•
- æµ‹è¯•æ•°æ®æ¨¡å‹è½¬æ¢
- æµ‹è¯•å·¥å…·å‡½æ•°
- æµ‹è¯•é”™è¯¯å¤„ç†é€»è¾‘

### é›†æˆæµ‹è¯•
- æµ‹è¯•é€‚é…å™¨ä¸ API äº¤äº’
- ä½¿ç”¨ mock æœåŠ¡å™¨æ¨¡æ‹Ÿå“åº”
- æµ‹è¯•é…ç½®åŠ è½½å’ŒéªŒè¯

### ç«¯åˆ°ç«¯æµ‹è¯•
- æµ‹è¯•å®Œæ•´åŒæ­¥æµç¨‹
- ä½¿ç”¨æµ‹è¯•ä»“åº“å’Œè´¦å·
- éªŒè¯åŒæ­¥ç»“æœæ­£ç¡®æ€§

## æœªæ¥æ‰©å±•

### çŸ­æœŸç›®æ ‡
- å®ç° Jira é€‚é…å™¨
- å®ç° CodeUp é€‚é…å™¨
- æ·»åŠ  watch æ¨¡å¼æ”¯æŒå®æ—¶åŒæ­¥

### ä¸­æœŸç›®æ ‡
- VSCode æ‰©å±•é›†æˆ
- åŒå‘åŒæ­¥ï¼ˆä»å¹³å°æ‹‰å–æ›´æ–°ï¼‰
- Web ä»ªè¡¨æ¿

### é•¿æœŸç›®æ ‡
- AI è¾…åŠ©ä»»åŠ¡æè¿°ç”Ÿæˆ
- åŒæ­¥åˆ†æå’ŒæŠ¥å‘Š
- å¤šå›¢é˜Ÿåä½œæ”¯æŒ

## æ­£ç¡®æ€§å±æ€§

æœ¬è®¾è®¡ç¡®ä¿ä»¥ä¸‹æ­£ç¡®æ€§å±æ€§ï¼š

1. **æ•°æ®ä¸€è‡´æ€§**ï¼šæºè§„æ ¼å’Œç›®æ ‡å¹³å°çš„æ•°æ®ä¿æŒä¸€è‡´
2. **å¹‚ç­‰æ€§**ï¼šå¤šæ¬¡åŒæ­¥äº§ç”Ÿç›¸åŒç»“æœ
3. **åŸå­æ€§**ï¼šå•ä¸ªé¡¹ç›®çš„åŒæ­¥æ“ä½œæ˜¯åŸå­çš„
4. **å¯è¿½æº¯æ€§**ï¼šæ‰€æœ‰å˜æ›´éƒ½æœ‰è¯¦ç»†è®°å½•
5. **é”™è¯¯éš”ç¦»**ï¼šå•ä¸ªå¤±è´¥ä¸å½±å“å…¶ä»–é¡¹ç›®

